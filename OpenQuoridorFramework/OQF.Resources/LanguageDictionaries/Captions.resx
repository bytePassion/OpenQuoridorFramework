<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
		Microsoft ResX Schema

		Version 1.3

		The primary goals of this format is to allow a simple XML format 
		that is mostly human readable. The generation and parsing of the 
		various data types are done through the TypeConverter classes 
		associated with the data types.

		Example:

		... ado.net/XML headers & schema ...
		<resheader name="resmimetype">text/microsoft-resx</resheader>
		<resheader name="version">1.3</resheader>
		<resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
		<resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
		<data name="Name1">this is my long string</data>
		<data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
		<data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
			[base64 mime encoded serialized .NET Framework object]
		</data>
		<data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
			[base64 mime encoded string representing a byte array form of the .NET Framework object]
		</data>

		There are any number of "resheader" rows that contain simple 
		name/value pairs.

		Each data row contains a name, and value. The row also contains a 
		type or mimetype. Type corresponds to a .NET class that support 
		text/value conversion through the TypeConverter architecture. 
		Classes that don't support this are serialized and stored with the 
		mimetype set.

		The mimetype is used for serialized objects, and tells the 
		ResXResourceReader how to depersist the object. This is currently not 
		extensible. For a given mimetype the value must be set accordingly:

		Note - application/x-microsoft.net.object.binary.base64 is the format 
		that the ResXResourceWriter will generate, however the reader can 
		read any of the formats listed below.

		mimetype: application/x-microsoft.net.object.binary.base64
		value   : The object must be serialized with 
			: System.Serialization.Formatters.Binary.BinaryFormatter
			: and then encoded with base64 encoding.

		mimetype: application/x-microsoft.net.object.soap.base64
		value   : The object must be serialized with 
			: System.Runtime.Serialization.Formatters.Soap.SoapFormatter
			: and then encoded with base64 encoding.

		mimetype: application/x-microsoft.net.object.bytearray.base64
		value   : The object must be serialized into a byte array 
			: using a System.ComponentModel.TypeConverter
			: and then encoded with base64 encoding.
	-->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>1.3</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.3500.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.3500.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="PvB_BrowseForBotButtonToolTipCaption" xml:space="preserve">
    <value>Browse for Bot-DLL</value>
  </data>
  <data name="PvB_StartGameButtonToolTipCaption" xml:space="preserve">
    <value>Start Game</value>
  </data>
  <data name="PvB_OpenInfoButtonToolTipCaption" xml:space="preserve">
    <value>Help and About</value>
  </data>
  <data name="PvB_BotNameLabelCaption" xml:space="preserve">
    <value>Bot Name</value>
  </data>
  <data name="PvB_MaximalThinkingTimeLabelCaption" xml:space="preserve">
    <value>Thinking-Time left</value>
  </data>
  <data name="PvB_WallsLeftLabelCaption" xml:space="preserve">
    <value>Walls</value>
  </data>
  <data name="PvB_ProgressCaption" xml:space="preserve">
    <value>Game Progress</value>
  </data>
  <data name="PvB_AutoScrollDownCheckBoxCaption" xml:space="preserve">
    <value>Auto scroll down</value>
  </data>
  <data name="PvB_DebugCaption" xml:space="preserve">
    <value>Debug</value>
  </data>
  <data name="PvB_CapitulateButtonCaption" xml:space="preserve">
    <value>Capitulate</value>
  </data>
  <data name="PvB_HeaderCaptionPlayer" xml:space="preserve">
    <value>Player</value>
  </data>
  <data name="WD_YesButtonCaption" xml:space="preserve">
    <value>Yes</value>
  </data>
  <data name="WD_NoButtonCaption" xml:space="preserve">
    <value>No</value>
  </data>
  <data name="WD_WinningMessage" xml:space="preserve">
    <value>Congratulations! You beated the bot!</value>
  </data>
  <data name="WD_Message_Reason" xml:space="preserve">
    <value>Reason</value>
  </data>
  <data name="WinningReason_RegularQuoridorWin" xml:space="preserve">
    <value>Regular win (first on the other side)</value>
  </data>
  <data name="WinningReason_Capitulation" xml:space="preserve">
    <value>Capitulation</value>
  </data>
  <data name="WinningReason_InvalidMode" xml:space="preserve">
    <value>Invalid move</value>
  </data>
  <data name="WinningReason_ExceedanceOfMaxMoves" xml:space="preserve">
    <value>The maximum of allowed moves was exceeded</value>
  </data>
  <data name="WinningReason_ExceedanceOfThoughtTime" xml:space="preserve">
    <value>The maximum thought time was exceeded</value>
  </data>
  <data name="WD_LoosingMessage" xml:space="preserve">
    <value>Sry ... you got beaten by the bot</value>
  </data>
  <data name="WD_SaveGameRequest" xml:space="preserve">
    <value>Do you want to save the Game?</value>
  </data>
  <data name="QRP_PageHeader" xml:space="preserve">
    <value>Quoridor - Rules</value>
  </data>
  <data name="QRP_GeneralParagraphHeader" xml:space="preserve">
    <value>General</value>
  </data>
  <data name="QRP_GeneralParagraphText" xml:space="preserve">
    <value>Quoridor is an abstract strategy game for 2 or 4 Player. The OpenQuoridorFramework only considers the 2-player-game. Therefor only those rules are presented here.</value>
  </data>
  <data name="QRP_GameSetupParagraphHeader" xml:space="preserve">
    <value>Game Setup</value>
  </data>
  <data name="QRP_GameSetupParagraphText" xml:space="preserve">
    <value>Quoridor is played on a board with 9 by 9 fields with spaces between these fields (picture 1). On the Board are two pawns, which are moved from field to field and there are 20 Walls that can be placed between the fields. On startup the pawns are placed on the fields e1 and e9 (see Quoridor-Notation). The player who controls the pawn on field e1 starts first.</value>
  </data>
  <data name="QRP_GameGoalParagraphHeader" xml:space="preserve">
    <value>Game Goal</value>
  </data>
  <data name="QRP_GameGoalParagraphText" xml:space="preserve">
    <value>The game ends immediately when one pawn reaches on field of the most opposite row. This player wins.</value>
  </data>
  <data name="QRP_GameFlowParagraphHeader" xml:space="preserve">
    <value>Game Flow</value>
  </data>
  <data name="QRP_GameFlowParagraphText" xml:space="preserve">
    <value>Both players move alternating until a winner is determined. When it is one player's turn, he have to choose between two different kinds of moves. Ether he has to move his pawn by one space or he has to place a wall on the board. If a player has no walls left, he has to move. The figure can only be moved by one space horizontal oder vertical, but not diagonal, not over a wall and not off the board. If the decides to place a wall, it is important to place this wall only between four fields, but not overlapping with another wall and not half off the board. It is also important that the opponend player always has a possible path to one of his goal-fields.</value>
  </data>
  <data name="QRP_SpecialMoveParagraphHeader" xml:space="preserve">
    <value>Special moving rules</value>
  </data>
  <data name="QRP_SpecialMoveParagraphText" xml:space="preserve">
    <value>If two pawns are in adjecent fields, so that one could step on the other (picture 2), this pawn can jump over the other pawn (picture 3). If the jumping pawn cannot reach the field behind the other pawn (because there is a wall or the end of the board), he can jump diagonal to the left or right of the pawn. Of course in this scenario the fields to jump on have to be reachable. The pictures 4 and 5 show two of these situations with the possible moves. </value>
  </data>
  <data name="QRP_Picture1Caption" xml:space="preserve">
    <value>Picture 1</value>
  </data>
  <data name="QRP_Picture2Caption" xml:space="preserve">
    <value>Picture 2</value>
  </data>
  <data name="QRP_Picture3Caption" xml:space="preserve">
    <value>Picture 3</value>
  </data>
  <data name="QRP_Picture4Caption" xml:space="preserve">
    <value>Picture 4</value>
  </data>
  <data name="QRP_Picture5Caption" xml:space="preserve">
    <value>Picture 5</value>
  </data>
  <data name="AP_PageHeader" xml:space="preserve">
    <value>About OpenQuoridorFramework</value>
  </data>
  <data name="AP_ApplicationSectionHeader" xml:space="preserve">
    <value>Application</value>
  </data>
  <data name="AP_VersionSectionHeader" xml:space="preserve">
    <value>Version</value>
  </data>
  <data name="AP_DeveloperSectionHeader" xml:space="preserve">
    <value>Developers</value>
  </data>
  <data name="AP_ThirdPartySectionHeader" xml:space="preserve">
    <value>3rd Party Usages</value>
  </data>
  <data name="AP_QuoridorSectionHeader" xml:space="preserve">
    <value>Quoridor</value>
  </data>
  <data name="AP_QuoridorInventorSubItem" xml:space="preserve">
    <value>Inventor</value>
  </data>
  <data name="AP_QuoridorPublisherSubItem" xml:space="preserve">
    <value>Publisher</value>
  </data>
  <data name="AP_LicenceSectionHeader" xml:space="preserve">
    <value>Licence</value>
  </data>
  <data name="QNP_PageHeader" xml:space="preserve">
    <value>Quoridor - Notation</value>
  </data>
  <data name="QNP_GeneralParagraphHeader" xml:space="preserve">
    <value>General</value>
  </data>
  <data name="QNP_GeneralParagraphText" xml:space="preserve">
    <value>Because there is no offical Quoridor-notation, one for was created for the OpenQuoridorFramework. It is derived from several notations used across the quoridor-community.</value>
  </data>
  <data name="QNP_TheBoardParagraphHeader" xml:space="preserve">
    <value>The Board</value>
  </data>
  <data name="QNP_TheBoardParagraphText" xml:space="preserve">
    <value>To address a field uniquely all rows are coded by the numbers 1 to 9 and all columns are coded by the letters 'a' to 'i' (picture 1). This results in a game-space of 81 fields from a1 in the lower left corner to i9 in the upper right corner.</value>
  </data>
  <data name="QNP_FigureMoveParagraphHeader" xml:space="preserve">
    <value>Move (Figure)</value>
  </data>
  <data name="QNP_FigureMoveParagraphText" xml:space="preserve">
    <value>A move, where the pawn is relocated is noted by the field he is stepping on. If, for example, a player moves from c3 to c4, this move is written down as 'c4'.</value>
  </data>
  <data name="QNP_WallMoveParagraphHeader" xml:space="preserve">
    <value>Move (Wall)</value>
  </data>
  <data name="QNP_WallMoveParagraphText" xml:space="preserve">
    <value>When a wall is placed on the board this move gets notates by the unique position of this wall. A wall have to be placed between four field. Therefore it is sufficent to store one of these four fields. This notation uses the upper left field for this purpose. Additional the orientation has to be noted. If the wall is placed vertically this is denoted by an 'v'. Or an 'h' for horizontal placed walls.</value>
  </data>
  <data name="QNP_ExampleParagraphHeader" xml:space="preserve">
    <value>Example</value>
  </data>
  <data name="QNP_ExampleParagraphText" xml:space="preserve">
    <value>In this notation the pawn on picture 2 are on 'c3' and 'e8'. The positions of the walls would be denoted as 'd4h' and 'f8v'.</value>
  </data>
  <data name="QNP_Picture1Caption" xml:space="preserve">
    <value>Picture 1</value>
  </data>
  <data name="QNP_Picture2Caption" xml:space="preserve">
    <value>Picture 2</value>
  </data>
  <data name="IP_QuoridorRulesButtonCaption" xml:space="preserve">
    <value>Quoridor Rules</value>
  </data>
  <data name="IP_QuoridorNotationButtonCaption" xml:space="preserve">
    <value>Quoridor Notation</value>
  </data>
  <data name="IP_HowToWriteABotButtonCaption" xml:space="preserve">
    <value>How to write a bot</value>
  </data>
  <data name="IP_ReplayViewerInfoButtonCaption" xml:space="preserve">
    <value>Application Help</value>
  </data>
  <data name="IP_PlayerVsBotInfoButtonCaption" xml:space="preserve">
    <value>Application Help</value>
  </data>
  <data name="IP_BotVsBotIntoButtonCaption" xml:space="preserve">
    <value>Application Help</value>
  </data>
  <data name="IP_TournamentInfoButtonCaption" xml:space="preserve">
    <value>Application Help</value>
  </data>
  <data name="IP_AboutButtonCaption" xml:space="preserve">
    <value>About</value>
  </data>
  <data name="IP_CloseButtonCaption" xml:space="preserve">
    <value>Close</value>
  </data>
  <data name="HTWAB_PageHeader" xml:space="preserve">
    <value>How to write a bot</value>
  </data>
  <data name="HTWAB_GeneralProceedingParagraphHeader" xml:space="preserve">
    <value>General Proceeding</value>
  </data>
  <data name="HTWAB_GeneralProceedingItem1" xml:space="preserve">
    <value>1. Create new solution with an empty project (of type ClassLibrary)</value>
  </data>
  <data name="HTWAB_GeneralProceedingItem2" xml:space="preserve">
    <value>2. Add OQF.Bot.Contracts.dll as reference to the project</value>
  </data>
  <data name="HTWAB_GeneralProceedingItem3" xml:space="preserve">
    <value>3. Create a bot-class and derive it from IQuoridorBot</value>
  </data>
  <data name="HTWAB_GeneralProceedingItem4" xml:space="preserve">
    <value>4. Implement the IQuoridor-interface</value>
  </data>
  <data name="HTWAB_GeneralProceedingItem5" xml:space="preserve">
    <value>5. Start an test-application (e.g. PlayerVsBot) and test your bot</value>
  </data>
  <data name="HTWAB_ImportantClassesParagraphHeader" xml:space="preserve">
    <value>Important Classes/Enums/Structs at the OQF.Bot.Contracts.dll</value>
  </data>
  <data name="HTWAB_ImportantClassesParagraphNote" xml:space="preserve">
    <value>Note: All classes and structs are designed and implemented as immutables.</value>
  </data>
  <data name="HTWAB_FieldCoordinateParagraphHeader" xml:space="preserve">
    <value>FieldCoordinate</value>
  </data>
  <data name="HTWAB_FieldCoordinateParagraphText" xml:space="preserve">
    <value>A FieldCoordinate defines a unique position on the board (see Quoridor-notation). The X- and Y-coordinate are implemented as enumerations.</value>
  </data>
  <data name="HTWAB_PlayerAndStateParagraphHeader" xml:space="preserve">
    <value>Player and PlayerState</value>
  </data>
  <data name="HTWAB_PlayerAndStateParagraphText" xml:space="preserve">
    <value>The Player-class defines the invariant values of a player. These are the name of player and his starting position (PlayerType) on the board. The current status of a player is represented by the PlayerState-class. There you can find a reference to the player, the current position of the player on the board and number of wall the has left to spend.</value>
  </data>
  <data name="HTWAB_WallParagraphHeader" xml:space="preserve">
    <value>Wall</value>
  </data>
  <data name="HTWAB_WallParagraphText" xml:space="preserve">
    <value>The Wall-Class defines a wall on the board by its position and orientation (see Quoridor-notation). The position is FieldCoordinate and the orientation is defined by another enumeration.</value>
  </data>
  <data name="HTWAB_BoardStateParagraphHeader" xml:space="preserve">
    <value>BoardState</value>
  </data>
  <data name="HTWAB_BoardStateParagraphText" xml:space="preserve">
    <value>The current situation on the board is represented by the BoardState-class. All game-relevant informations are stored in it: all placed walls, the states of both players and the player who's turn it is. Additional to that can the complete game-history be reviewed by looking at LastBoardState and LastMove.</value>
  </data>
  <data name="HTWAB_MovesParagraphHeader" xml:space="preserve">
    <value>Move(s)</value>
  </data>
  <data name="HTWAB_MovesParagraphText" xml:space="preserve">
    <value>Based on the abstract superclass Move, there are 3 different moves to choose from each turn. The FigureMove, to move the Pawn, the WallMove, to place a wall on the board, and the Capitulation, if you think there is no chance of winning any more.</value>
  </data>
  <data name="HTWAB_GameConstraintsParagraphHeader" xml:space="preserve">
    <value>GameContraints</value>
  </data>
  <data name="HTWAB_GameConstraintsParagraphText" xml:space="preserve">
    <value>The GameConstraints-class contains the two restrictions for a bot for a game. One is the maximal timespan a bot can take to think about its next move. The other is the maximum of total moves each player can make in this game, before it is aborted.</value>
  </data>
  <data name="HTWAB_GameFlowParagraphHeader" xml:space="preserve">
    <value>The bot's view of the Gameflow</value>
  </data>
  <data name="HTWAB_GameFlowItem1" xml:space="preserve">
    <value>1. The method Init(PlayerType, GameConstraints) is called. Thereby the bot is told on which side of the board he is starting and how the constraints for the upcomming game are.</value>
  </data>
  <data name="HTWAB_GameFlowItem2" xml:space="preserve">
    <value>2. Now the game is started. Every time when its the turn of the bot, the method DoMove(BoardState) is called. The argument tells how the current situation of the board is.</value>
  </data>
  <data name="HTWAB_GameFlowItem3" xml:space="preserve">
    <value>3. Now the bot has so much time, as the GameConstraints told him, to fire the NextMoveAvailable-Event to submit his next move.</value>
  </data>
  <data name="HTWAB_GameFlowItem4" xml:space="preserve">
    <value>4. Then it is the opponend players turn. When he has finished moving and it is your turn again, the DoMove(BoardState)-method is called again. This will be repeated until there is a winner.</value>
  </data>
  <data name="HTWAB_GameFlowItem5" xml:space="preserve">
    <value>5. A bot can always submit a debug-message to the UI by fireing the DebugMessageAvailable-Event.</value>
  </data>
  <data name="HTWAB_ExampleParagraphHeader" xml:space="preserve">
    <value>Examplary implementation</value>
  </data>
  <data name="HTWAB_ExampleParagraphText" xml:space="preserve">
    <value>The SimpleWalking bot is an examplary bot-implementation. You find it within the OpenQoridorFramework at 'OpenQuoridorFramework/Bots/SimpleWalkingBot/SimpleWalkingBot.cs' within the Git-repository (see About).</value>
  </data>
  <data name="AP_SourceCodeSectionHeader" xml:space="preserve">
    <value>SourceCode</value>
  </data>
  <data name="AP_SourceCodeSectionText" xml:space="preserve">
    <value>The sourceCode of the OpenQuoridorFramework can be found on gitHub</value>
  </data>
  <data name="PvB_DumpDebugToFileButtonCaption" xml:space="preserve">
    <value>Save</value>
  </data>
  <data name="PvBH_PageHeader" xml:space="preserve">
    <value>Overview to 'Player vs Bot'</value>
  </data>
  <data name="PvBH_Explanation01" xml:space="preserve">
    <value>1. Browse for a bot-dll on the hard-drive and load it</value>
  </data>
  <data name="PvBH_Explanation02" xml:space="preserve">
    <value>2. Start a game (if a bot was loaded)</value>
  </data>
  <data name="PvBH_Explanation03" xml:space="preserve">
    <value>3. Start a game from progress-file (if a bot was loaded)</value>
  </data>
  <data name="PvBH_Explanation04" xml:space="preserve">
    <value>4. Name of the bot you are playing against</value>
  </data>
  <data name="PvBH_Explanation05" xml:space="preserve">
    <value>5. Choose language</value>
  </data>
  <data name="PvBH_Explanation06" xml:space="preserve">
    <value>6. Open Help</value>
  </data>
  <data name="PvBH_Explanation07" xml:space="preserve">
    <value>7. Expand or collapse the game-progress</value>
  </data>
  <data name="PvBH_Explanation08" xml:space="preserve">
    <value>8. Save current game-progress to a text-file</value>
  </data>
  <data name="PvBH_Explanation09" xml:space="preserve">
    <value>9. Activate/deactivate auto-scroll-down of the game-progress</value>
  </data>
  <data name="PvBH_Explanation10" xml:space="preserve">
    <value>10. The progress of the ongoing game</value>
  </data>
  <data name="PvBH_Explanation11" xml:space="preserve">
    <value>11. Number of walls, which the bot has left to spend</value>
  </data>
  <data name="PvBH_Explanation12" xml:space="preserve">
    <value>12. Save current debug-output to a text-file</value>
  </data>
  <data name="PvBH_Explanation13" xml:space="preserve">
    <value>13. Activate/deactivate auto-scroll-down of the debug-output</value>
  </data>
  <data name="PvBH_Explanation14" xml:space="preserve">
    <value>14. Expand or collapse the debug-output</value>
  </data>
  <data name="PvBH_Explanation15" xml:space="preserve">
    <value>15. Debug-output of the ongoing game</value>
  </data>
  <data name="PvBH_Explanation16" xml:space="preserve">
    <value>16. Placed walls on the boad</value>
  </data>
  <data name="PvBH_Explanation17" xml:space="preserve">
    <value>17. Pawn of the bot (white)</value>
  </data>
  <data name="PvBH_Explanation18" xml:space="preserve">
    <value>18. Pawn of the player (black)</value>
  </data>
  <data name="PvBH_Note" xml:space="preserve">
    <value>Note: To submit a move just click on the board on the UI. You get a preview for wall-placement as well as for moving the pawn.</value>
  </data>
  <data name="PvB_DumpDebugFileDialogTitle" xml:space="preserve">
    <value>Save current Debug output</value>
  </data>
  <data name="PvB_SaveGameProgressFileDialogTitle" xml:space="preserve">
    <value>Save Game Progress of currently ended game</value>
  </data>
  <data name="ErrorMsg_NoDllPath" xml:space="preserve">
    <value>You have to choose a Bot-DLL before Starting a game</value>
  </data>
  <data name="ErrorMsg_FileDoesNotExist" xml:space="preserve">
    <value>File does not exist</value>
  </data>
  <data name="ErrorMsg_FileIsNoAssembly" xml:space="preserve">
    <value>File is no valid assembly</value>
  </data>
  <data name="ErrorMsg_BotCanNotBeLoadedFromAsembly" xml:space="preserve">
    <value>Bot cannot be loaded as assembly</value>
  </data>
  <data name="ND_OkButtonCaption" xml:space="preserve">
    <value>Ok</value>
  </data>
  <data name="PvB_DumpProgressToFileButtonCaption" xml:space="preserve">
    <value>Save</value>
  </data>
  <data name="PvB_DumpProgressFileDialogTitle" xml:space="preserve">
    <value>Save current Progress</value>
  </data>
  <data name="PvB_StartWithProgressGameButtonToolTipCaption" xml:space="preserve">
    <value>Start Game from Progress-File</value>
  </data>
  <data name="PVR_EmptyOrInvalid" xml:space="preserve">
    <value>The progress is empty or invalid</value>
  </data>
  <data name="PVR_ProgressContainsInvalidMove" xml:space="preserve">
    <value>The progress contains an invalid move</value>
  </data>
  <data name="PVR_ProgressContainsTerminatedGame" xml:space="preserve">
    <value>The progress contains a game which already ended</value>
  </data>
  <data name="PVR_ErrorMsg_Reason" xml:space="preserve">
    <value>Reason</value>
  </data>
  <data name="HTWAB_HintParagraphHeader" xml:space="preserve">
    <value>Hint</value>
  </data>
  <data name="HTWAB_HintParagraphText" xml:space="preserve">
    <value>You can simplify your debugging-process by modifying the properties of your bot-project in a way that the test-application PlayerVsBot is started automaticly with the bot loaded every time you start debugging. To do so (an example is shown in the picture above) you have to adjust the StartAction to launch the PlayerVsBot-application. In addition to that you have to add the result of the build-process (your bot-dll) as command-line-parameter for the test-application. Don't forget the quotation marks! There are three more possible CommandLine-Parameters. With "-disableBotTimeout" you can debug your bot as long as you want, without being interrupted by the bot's thinking-time-limit. And with "-disableClosingDialog" you can supress the dialogs which would be displayed if you close the program during a game. With '-progressFile="[...]"' you can start the game directly from an game-progress-file. This is helpful to debug a certain situation.</value>
  </data>
  <data name="PvBH_Explanation19" xml:space="preserve">
    <value>19. Possible moving-field for your pawn</value>
  </data>
  <data name="PvBH_Explanation20" xml:space="preserve">
    <value>20. Resign from the game -&gt; the bot wins</value>
  </data>
  <data name="PvBH_Explanation21" xml:space="preserve">
    <value>21. Number of walls, which you have left to spend</value>
  </data>
  <data name="ClosingDialogMessage" xml:space="preserve">
    <value>Do you want exit during a ongoing game?</value>
  </data>
  <data name="SavingDialogMessage" xml:space="preserve">
    <value>Do you want to save the current game progress?</value>
  </data>
  <data name="PvB_MovesLeftLabelCaption" xml:space="preserve">
    <value>Moves left</value>
  </data>
  <data name="PVR_ProgressContainsMoreMovesThanAllowed" xml:space="preserve">
    <value>The progress contains more moves than allowed in the upcomming game</value>
  </data>
  <data name="AP_ApplicationNameSubItem" xml:space="preserve">
    <value>Name</value>
  </data>
  <data name="AP_ApplicationVersionSubItem" xml:space="preserve">
    <value>Version</value>
  </data>
  <data name="PvB_CompressedProgressCaption" xml:space="preserve">
    <value>Compressed progress-string</value>
  </data>
  <data name="PvB_CopyToClipboardButtonToolTipCpation" xml:space="preserve">
    <value>Copy compressed progress to clipboad</value>
  </data>
  <data name="PVR_ErrorMsg_ProgressCannotBeLoaded" xml:space="preserve">
    <value>Connot be loaded as progress</value>
  </data>
  <data name="SID_OkButtonCaption" xml:space="preserve">
    <value>Ok</value>
  </data>
  <data name="SID_CancelButtonCaption" xml:space="preserve">
    <value>Cancel</value>
  </data>
  <data name="PvB_ProgressInputDialogPromt" xml:space="preserve">
    <value>Input the compressed Progress:</value>
  </data>
  <data name="PvB_StartGameFromStringButtonCaption" xml:space="preserve">
    <value>From string</value>
  </data>
  <data name="PvB_StartGameFromFileButtonCaption" xml:space="preserve">
    <value>From file</value>
  </data>
  <data name="PvB_NoBotLoadedCaption" xml:space="preserve">
    <value>&gt;&gt;no bot loded&lt;&lt;</value>
  </data>
</root>